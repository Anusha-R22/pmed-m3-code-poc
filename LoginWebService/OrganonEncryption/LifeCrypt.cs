// ===============================================================================
// LifeCrypt.cs
//
// AES Encryption and Decryption for Life Program.
// Information:
// - http://msdn2.microsoft.com/en-us/library/system.security.cryptography.rijndaelmanaged.aspx
// - http://blogs.msdn.com/dotnetinterop/archive/2005/01/24/359898.aspx
// - http://en.wikipedia.org/wiki/Advanced_Encryption_Standard
// - http://www.obviex.com/samples/Encryption.aspx
//
// Author: Lee Provoost (LP), Capgemini (lee.provoost@capgemini.com)
// Date  : 10-11-'06
//
// ===============================================================================
// Release history
// VERSION	DATE        WHO     DESCRIPTION 
//   1.6    25/01/07    LP      Extended 30 seconds to 120 seconds before and after server's time.
//   1.5    01/12/06    LP      Code clean up.
//   1.4    12/11/06    LP      Timestamps are now locale independent
//   1.3    12/11/06    LP      Added timestamp-based security and error return codes for Decrypt.
//   1.2    11/11/06    LP      Refactored members to constants
//   1.1    11/11/06    LP      Added COM Interop
//   1.0	10/11/06    LP      Initial version.
// ===============================================================================

using System;
using System.IO;
using System.Text;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text.RegularExpressions;

namespace Organon.Oss.ISD.TrialsUsers
{
    #region Interface

    /// <summary>
    /// The COM interop interface for the LifeCrypt class.
    /// </summary>
    [Guid("91B04185-74D3-4439-87C6-9F0C843C2FD3")]
    [InterfaceType(ComInterfaceType.InterfaceIsDual)]
    public interface ILifeCrypt
    {
        /// <summary>
        /// Encrypts specified plaintext using Rijndael symmetric key algorithm
        /// and returns a base64-encoded result.
        /// </summary>
        /// <param name="plainText">
        /// Plaintext value to be encrypted.
        /// </param>
        /// <returns>
        /// Encrypted value formatted as a base64-encoded string.
        /// </returns>
        /// <remarks>
        ///     <code>
        ///         string plainText = "Hello, World!";
        ///         Console.WriteLine(String.Format("Plaintext : {0}", plainText));
        ///         string cipherText = LifeCrypt.Encrypt(plainText);
        ///     </code>
        /// </remarks>
        string Encrypt(string plainText);

        /// <summary>
        /// Decrypts specified ciphertext using Rijndael symmetric key algorithm.
        /// </summary>
        /// <param name="cipherText">
        /// Base64-formatted ciphertext value.
        /// </param>
        /// <returns>
        /// Decrypted string value or error code:
        /// ERR_0: Ticket no longer valid.
        /// ERR_1: Supplied ticket format is not valid.
        /// ERR_2: Ticket Timestamp > Now Timestamp
        /// ERR_3: Not a valid Base64 Encoded string supplied.
        /// ERR_4: Catch unhandled exceptions. Shouldn't occur.
        /// </returns>
        /// <remarks>
        ///     <code>
        ///         string cipherText = LifeCrypt.Encrypt(plainText);
        ///         Console.WriteLine(String.Format("Encrypted : {0}", cipherText));
        ///         string plainText = LifeCrypt.Decrypt(cipherText);
        ///         Console.WriteLine(String.Format("Decrypted : {0}", plainText));
        ///     </code>
        /// </remarks>
        string Decrypt(string cipherText);
    }

    #endregion

    #region Implementation

    /// <summary>
    /// Encrypts and decrypts using Rijndael symmetric key algorithm.
    /// </summary>
    [ClassInterface(ClassInterfaceType.AutoDual),
        ComDefaultInterface(typeof(ILifeCrypt)),
        ComVisible(true),
        ProgId("TrialsUsers.LifeCrypt"),
        Guid("A9B908B4-E07F-49e4-B4E4-BC02E4B003B8"),
        Serializable]
    public class LifeCrypt : ILifeCrypt
    {
        #region Constructor

        /// <summary>
        /// Constructor
        /// </summary>
        public LifeCrypt() { }

        #endregion

        #region Private fields

        const int KEYSIZE = 256;
        const int PASSWORDITERATIONS = 2;
        const string HASHALGORTIHM = "SHA1";
        const string INITVECTOR = "@1BdcqD4e5F3g7HZ";
        const string PASSPHRASE = "3103b2528e7017e454226c58082a065569554d98";
        const string SALTVALUE = "5931f94c6184dbd50a176204be2c9d77c24991d3";
        const int TICKET_VALIDITY = 120;

        #endregion

        #region Private methods

        /// <summary>
        /// Checks the timestamp associated with the encrypted text.
        /// </summary>
        /// <param name="ticket">
        /// String with the text and timestamp. This string is generated by the Encrypt method.
        /// </param>
        /// <returns>
        /// String value with timestamp stripped off or error code:
        /// ERR_0: Ticket no longer valid.
        /// ERR_1: Supplied ticket format is not valid.
        /// ERR_3: Not a valid Base64 Encoded string supplied.
        /// </returns>
        public string CheckTicketValidity(string ticket)
        {
            string error = "";
            string content = "";
            int diffSeconds = 0;
            // ticket = "Hello, World! [[16-11-2006 15:15:00]]";
            string pattern = @"^(.*) \[{2}(\d{1,2})-(\d{1,2})-(\d{4}) (\d{1,2}):(\d{1,2}):(\d{1,2})\]{2}$";
            Regex r = new Regex(pattern, RegexOptions.IgnoreCase);
            Match m = r.Match(ticket);
            if (m.Success)
            {
                content = m.Groups[1].ToString();
                int day = Convert.ToInt32(m.Groups[2].ToString());
                int month = Convert.ToInt32(m.Groups[3].ToString());
                int year = Convert.ToInt32(m.Groups[4].ToString());
                int hour = Convert.ToInt32(m.Groups[5].ToString());
                int minute = Convert.ToInt32(m.Groups[6].ToString());
                int second = Convert.ToInt32(m.Groups[7].ToString());
                DateTime dateOld = new DateTime(year, month, day, hour, minute, second);
                DateTime dateNew = DateTime.Now.ToUniversalTime();
                TimeSpan diffResult = dateNew - dateOld;
                diffSeconds = Convert.ToInt32(diffResult.TotalSeconds);
                if (Math.Abs(diffSeconds) > TICKET_VALIDITY)
                {
                    // Ticket no longer valid
                    error = "ERR_0";
                }
            }
            else
            {
                // Supplied ticket format is not valid
                error = "ERR_1";
            }
            if (String.IsNullOrEmpty(error))
            {
                return content;
            }
            else
            {
                return error;
            }
        }

        #endregion


        #region Public methods

        /// <summary>
        /// Encrypts specified plaintext using Rijndael symmetric key algorithm
        /// and returns a base64-encoded result.
        /// </summary>
        /// <param name="plainText">
        /// Plaintext value to be encrypted.
        /// </param>
        /// <returns>
        /// Encrypted value formatted as a base64-encoded string.
        /// </returns>
        /// <remarks>
        ///     <code>
        ///         string plainText = "Hello, World!";
        ///         Console.WriteLine(String.Format("Plaintext : {0}", plainText));
        ///         string cipherText = LifeCrypt.Encrypt(plainText);
        ///     </code>
        /// </remarks>
        public string Encrypt(string plainText)
        {
            // Create locale independent timestamp
            DateTime dt = DateTime.Now.ToUniversalTime();
            String timestamp = dt.Day + "-" + dt.Month + "-" + dt.Year + " " + dt.Hour + ":" + dt.Minute + ":" + dt.Second;
            // Add timestamp to plainText
            plainText = plainText + " [[" + timestamp + "]]";
            // Convert strings into byte arrays.
            // Let us assume that strings only contain ASCII codes.
            // If strings include Unicode characters, use Unicode, UTF7, or UTF8 
            // encoding.
            byte[] initVectorBytes = Encoding.ASCII.GetBytes(INITVECTOR);
            byte[] saltValueBytes = Encoding.ASCII.GetBytes(SALTVALUE);
            // Convert our plaintext into a byte array.
            // Let us assume that plaintext contains UTF8-encoded characters.
            byte[] plainTextBytes = Encoding.UTF8.GetBytes(plainText);
            // First, we must create a password, from which the key will be derived.
            // This password will be generated from the specified passphrase and 
            // salt value. The password will be created using the specified hash 
            // algorithm. Password creation can be done in several iterations.
            PasswordDeriveBytes password = new PasswordDeriveBytes(PASSPHRASE, saltValueBytes, HASHALGORTIHM, PASSWORDITERATIONS);
            // Use the password to generate pseudo-random bytes for the encryption
            // key. Specify the size of the key in bytes (instead of bits).
            byte[] keyBytes = password.GetBytes(KEYSIZE / 8);
            // Create uninitialized Rijndael encryption object.
            RijndaelManaged symmetricKey = new RijndaelManaged();
            // It is reasonable to set encryption mode to Cipher Block Chaining
            // (CBC). Use default options for other symmetric key parameters.
            symmetricKey.Mode = CipherMode.CBC;
            // Generate encryptor from the existing key bytes and initialization 
            // vector. Key size will be defined based on the number of the key 
            // bytes.
            ICryptoTransform encryptor = symmetricKey.CreateEncryptor(keyBytes, initVectorBytes);
            // Define memory stream which will be used to hold encrypted data.
            MemoryStream memoryStream = new MemoryStream();
            // Define cryptographic stream (always use Write mode for encryption).
            CryptoStream cryptoStream = new CryptoStream(memoryStream, encryptor, CryptoStreamMode.Write);
            // Start encrypting.
            cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);
            // Finish encrypting.
            cryptoStream.FlushFinalBlock();
            // Convert our encrypted data from a memory stream into a byte array.
            byte[] cipherTextBytes = memoryStream.ToArray();
            // Close both streams.
            memoryStream.Close();
            cryptoStream.Close();
            // Convert encrypted data into a base64-encoded string.
            string cipherText = Convert.ToBase64String(cipherTextBytes);
            // Return encrypted string.
            return cipherText;
        }

        /// <summary>
        /// Decrypts specified ciphertext using Rijndael symmetric key algorithm.
        /// </summary>
        /// <param name="cipherText">
        /// Base64-formatted ciphertext value.
        /// </param>
        /// <returns>
        /// Decrypted string value or error code:
        /// ERR_0: Ticket no longer valid.
        /// ERR_1: Supplied ticket format is not valid.
        /// ERR_2: Ticket Timestamp > Now Timestamp
        /// ERR_3: Not a valid Base64 Encoded string supplied.
        /// ERR_4: Catch unhandled exceptions. Shouldn't occur.
        /// </returns>
        /// <remarks>
        ///     <code>
        ///         string cipherText = LifeCrypt.Encrypt(plainText);
        ///         Console.WriteLine(String.Format("Encrypted : {0}", cipherText));
        ///         string plainText = LifeCrypt.Decrypt(cipherText);
        ///         Console.WriteLine(String.Format("Decrypted : {0}", plainText));
        ///     </code>
        /// </remarks>
        public string Decrypt(string cipherText)
        {
            try
            {
                // Convert strings defining encryption key characteristics into byte
                // arrays. Let us assume that strings only contain ASCII codes.
                // If strings include Unicode characters, use Unicode, UTF7, or UTF8
                // encoding.
                byte[] initVectorBytes = Encoding.ASCII.GetBytes(INITVECTOR);
                byte[] saltValueBytes = Encoding.ASCII.GetBytes(SALTVALUE);
                // Convert our ciphertext into a byte array.
                byte[] cipherTextBytes = Convert.FromBase64String(cipherText);
                // First, we must create a password, from which the key will be 
                // derived. This password will be generated from the specified 
                // passphrase and salt value. The password will be created using
                // the specified hash algorithm. Password creation can be done in
                // several iterations.
                PasswordDeriveBytes password = new PasswordDeriveBytes(PASSPHRASE, saltValueBytes, HASHALGORTIHM, PASSWORDITERATIONS);
                // Use the password to generate pseudo-random bytes for the encryption
                // key. Specify the size of the key in bytes (instead of bits).
                byte[] keyBytes = password.GetBytes(KEYSIZE / 8);
                // Create uninitialized Rijndael encryption object.
                RijndaelManaged symmetricKey = new RijndaelManaged();
                // It is reasonable to set encryption mode to Cipher Block Chaining
                // (CBC). Use default options for other symmetric key parameters.
                symmetricKey.Mode = CipherMode.CBC;
                // Generate decryptor from the existing key bytes and initialization 
                // vector. Key size will be defined based on the number of the key 
                // bytes.
                ICryptoTransform decryptor = symmetricKey.CreateDecryptor(keyBytes, initVectorBytes);
                // Define memory stream which will be used to hold encrypted data.
                MemoryStream memoryStream = new MemoryStream(cipherTextBytes);
                // Define cryptographic stream (always use Read mode for encryption).
                CryptoStream cryptoStream = new CryptoStream(memoryStream, decryptor, CryptoStreamMode.Read);
                // Since at this point we don't know what the size of decrypted data
                // will be, allocate the buffer long enough to hold ciphertext;
                // plaintext is never longer than ciphertext.
                byte[] plainTextBytes = new byte[cipherTextBytes.Length];
                // Start decrypting.
                int decryptedByteCount = cryptoStream.Read(plainTextBytes, 0, plainTextBytes.Length);
                // Close both streams.
                memoryStream.Close();
                cryptoStream.Close();
                // Convert decrypted data into a string. 
                // Let us assume that the original plaintext string was UTF8-encoded.
                string plainText = Encoding.UTF8.GetString(plainTextBytes, 0, decryptedByteCount);
                // Return decrypted string.   
                return CheckTicketValidity(plainText);
            }
            catch (FormatException)
            {
                // ERR_4: Not a valid Base64 Encoded string supplied;
                return "ERR_3";
            }
            catch (Exception)
            {
                // ERR_4: Catch unhandled exceptions. Shouldn't occur.
                return "ERR_4";
            }
        }

        #endregion

    }

    #endregion

}